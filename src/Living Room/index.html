<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Isometric Room</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="stylesheet" href="styles/style.css" />
  </head>

  <body>
    <div id="loader"></div>
    <div id="container"></div>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="/js/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "/js/threejs/three.module.js",
          "three/addons/": "/js/threejs/jsm/"
        }
      }
    </script>
    <script type="text/javascript">
      //Global variables
      var fps = 24;
      var orbitalControl,
        musicLight,
        musicLightIntensity = 50,
        cameraContainer,
        isSignalNotFound = true,
        isDebugging = true;

      //Using two separate canvas to simplify code
      let canvasArtist = document.createElement("canvas");
      let canvasClock = document.createElement("canvas");
      let canvasPhoto = document.createElement("canvas");
      canvasArtist.width = 640;
      canvasArtist.height = 360;
      canvasPhoto.width = 360;
      canvasPhoto.height = 640;
      canvasClock.width = canvasClock.height = 300;
    </script>
    <script type="module">
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      // import { RectAreaLightUniformsLib } from "three/addons/lights/RectAreaLightUniformsLib.js";

      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { FilmPass } from "three/addons/postprocessing/FilmPass.js";

      //let musicLight;
      let camera, scene, renderer, composer;
      let canvasTextureArtist, canvasTextureClock, canvasTexturePhoto;
      //let stats;

      // isSignalNotFound video using threejs texture
      let htmlVideoScreenObject;
      let htmlVideo = document.createElement("video");
      htmlVideo.src = `textures/no_signal.webm`;
      htmlVideo.muted = true;
      htmlVideo.loop = true;
      htmlVideo.play();

      //orthographic camera params
      const frustumSize = 20,
        resizeWidth = false;

      function init() {
        const container = document.getElementById("container");

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        //renderer.setAnimationLoop(render);
        //renderer.setClearColor(0x000000, 0.0);

        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        //renderer.toneMappingExposure = 1;
        container.appendChild(renderer.domElement);

        composer = new EffectComposer(renderer);
        window.addEventListener("resize", onWindowResize);

        //stats = new Stats();
        //container.appendChild(stats.dom);

        //camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.25, 1000);
        if (resizeWidth) {
          let aspect = window.innerHeight / window.innerWidth;
          camera = new THREE.OrthographicCamera(
            frustumSize / -2,
            frustumSize / 2,
            (frustumSize * aspect) / 2,
            (frustumSize * aspect) / -2,
            0.25,
            1000
          );
        } else {
          let aspect = window.innerWidth / window.innerHeight;
          camera = new THREE.OrthographicCamera(
            (-aspect * frustumSize) / 2,
            (aspect * frustumSize) / 2,
            frustumSize / 2,
            -frustumSize / 2,
            0.25,
            1000
          );
        }
        cameraContainer = new THREE.Object3D();
        cameraContainer.add(camera);
        //cameraContainer.position.set(0, 0, 0);
        cameraContainer.rotation.x = (Math.PI / 180) * -30;
        cameraContainer.rotation.y = (Math.PI / 180) * 30;

        orbitalControl = new OrbitControls(camera, container);
        orbitalControl.enableDamping = true;
        orbitalControl.minDistance = 18;
        orbitalControl.maxDistance = 50;
        orbitalControl.minAzimuthAngle = Math.PI * -0.5;
        orbitalControl.maxAzimuthAngle = Math.PI * 0.5;
        orbitalControl.target.set(0, 0, -0.1);
        orbitalControl.enabled = isDebugging;
        //orbitalControl.autoRotate = true;
        orbitalControl.update();

        //Lighting and environment
        scene = new THREE.Scene();
        //RectAreaLightUniformsLib.init();
        //scene.background = new THREE.Color(0x000000);
        //scene.background = new THREE.TextureLoader().load( "textures/background.png" );
        //scene.environment = new RGBELoader().load("textures/colorful_studio_1k.hdr");
        scene.environment = new RGBELoader().load("textures/cave_wall_1k.hdr");
        scene.environment.mapping = THREE.EquirectangularReflectionMapping;

        musicLight = new THREE.PointLight(0xff0000, musicLightIntensity, 4);
        musicLight.position.set(0, 1.25, -3.75);
        //light.lookAt( 0, 0, 0 );
        scene.add(musicLight);

        //sun
        const directionalLight = new THREE.SpotLight(0xffffff, 1);
        directionalLight.position.set(-10, 75, 0);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        let roomLight = new THREE.PointLight(0xcecca7, 4, 8);
        roomLight.position.set(-3.5, 2, 1.5);
        roomLight.castShadow = true;
        scene.add(roomLight);
        //const pointLightHelper = new THREE.PointLightHelper(roomLight, 1);
        //scene.add(pointLightHelper);

        //Photo frame light
        // const spotLight = new THREE.SpotLight(0xffffff, 4, 10, (Math.PI / 180) * 15, 0, 4);
        // spotLight.castShadow = true;
        // spotLight.position.set(-4, 3.4, -0.75);
        // const targetObject = new THREE.Object3D();
        // scene.add(targetObject);
        // targetObject.position.set(-4, 0, -0.75);
        // spotLight.target = targetObject;
        // scene.add(spotLight);
        //const spotLightHelper = new THREE.SpotLightHelper(spotLight);
        //scene.add(spotLightHelper);

        //Load model
        const loader = new GLTFLoader();
        loader.load("models/Room 2.1.glb", function (gltf) {
          // const planeGeometry = new THREE.PlaneGeometry(10, 10);
          // const bottomPlane = new THREE.Mesh(
          //   planeGeometry,
          //   new THREE.ShadowMaterial({
          //     // color: new THREE.Color(0x000000),
          //   })
          // );
          // bottomPlane.receiveShadow = true;
          // bottomPlane.position.set(0, -2.5, 0);
          // bottomPlane.rotation.x = (Math.PI / 180) * -90;
          // scene.add(bottomPlane);

          gltf.scene.position.set(0, -2.5, 0);

          gltf.scene.traverse(function (child) {
            if (child.isMesh) child.castShadow = true;
            console.log(child);
          });

          canvasTextureArtist = new THREE.CanvasTexture(canvasArtist);
          canvasTextureArtist.encoding = THREE.sRGBEncoding;
          canvasTextureArtist.flipY = false;
          const canvasMaterialArtist = new THREE.MeshBasicMaterial({ map: canvasTextureArtist, transparent: false });

          canvasTexturePhoto = new THREE.CanvasTexture(canvasPhoto);
          canvasTexturePhoto.encoding = THREE.sRGBEncoding;
          canvasTexturePhoto.flipY = false;
          const canvasMaterialPhoto = new THREE.MeshBasicMaterial({ map: canvasTexturePhoto, transparent: false });

          canvasTextureClock = new THREE.CanvasTexture(canvasClock);
          canvasTextureClock.flipY = false;
          canvasTextureClock.anisotropy = 4;
          const canvasMaterialClock = new THREE.MeshBasicMaterial({ map: canvasTextureClock, transparent: false });

          //model objects
          let screenArtist = gltf.scene.getObjectByName("TV_SCREEN");
          let screenClock = gltf.scene.getObjectByName("CLOCK_SCREEN");
          let screenPhoto = gltf.scene.getObjectByName("PICTURE_FRAME");
          console.log(screenPhoto.material);

          //Baked texture is MeshBasic otherwise (no real-time lighting.)
          meshBasicToStandardMesh(gltf.scene.getObjectByName("Room"));
          meshBasicToStandardMesh(gltf.scene.getObjectByName("Tv_Cabinet"));
          meshBasicToStandardMesh(gltf.scene.getObjectByName("Cube003")); //table2
          meshBasicToStandardMesh(gltf.scene.getObjectByName("1001")); //guitar
          meshBasicToStandardMesh(gltf.scene.getObjectByName("1")); //plant

          //no signal video
          let videoTexture = new THREE.VideoTexture(htmlVideo);
          videoTexture.format = THREE.RGBAFormat;
          videoTexture.minFilter = THREE.NearestFilter;
          videoTexture.maxFilter = THREE.NearestFilter;
          videoTexture.generateMipmaps = false;
          videoTexture.flipY = false;
          var videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, transparent: false });

          htmlVideoScreenObject = screenArtist.clone(false);
          screenArtist.getWorldPosition(htmlVideoScreenObject.position);
          screenArtist.getWorldQuaternion(htmlVideoScreenObject.quaternion);
          htmlVideoScreenObject.position.set(
            htmlVideoScreenObject.position.x,
            htmlVideoScreenObject.position.y,
            htmlVideoScreenObject.position.z + 0.002
          );

          screenArtist.material = canvasMaterialArtist;
          screenClock.material = canvasMaterialClock;
          screenPhoto.material = canvasMaterialPhoto;
          htmlVideoScreenObject.material = videoMaterial;
          scene.add(gltf.scene);
          scene.add(htmlVideoScreenObject);

          showScene();
        });

        //post processing
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        //const filmPass = new FilmPass(1, 0.1, 1024, 0);
        //composer.addPass(filmPass);

        //const bloomPass = new UnrealBloomPass(new THREE.Vector2(256, 256), 1, 0.2, 0.8);
        //composer.addPass(bloomPass);
      }

      function meshBasicToStandardMesh(object) {
        let oldMat = object.material;
        let newMat = new THREE.MeshStandardMaterial();
        //THREE.MeshStandardMaterial.prototype.copy.call( newMat, oldMat );
        //newMat.copy(oldMat);
        newMat.map = oldMat.map;
        object.material = newMat;
      }

      function onWindowResize() {
        if (resizeWidth) {
          let aspect = window.innerHeight / window.innerWidth;
          camera.left = frustumSize / -2;
          camera.right = frustumSize / 2;
          camera.top = (frustumSize * aspect) / 2;
          camera.bottom = (-frustumSize * aspect) / 2;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        } else {
          let aspect = window.innerWidth / window.innerHeight;
          camera.left = (-aspect * frustumSize) / 2;
          camera.right = (aspect * frustumSize) / 2;
          camera.top = frustumSize / 2;
          camera.bottom = -frustumSize / 2;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      function render() {
        //fps control
        setTimeout(function () {
          requestAnimationFrame(render);
        }, 1000 / fps);

        orbitalControl.update();

        const time = -performance.now() / 1000;
        if (canvasTextureArtist != null) {
          canvasTextureArtist.needsUpdate = true;
        }

        if (canvasTextureClock != null) {
          canvasTextureClock.needsUpdate = true;
        }

        if (canvasTexturePhoto != null) {
          canvasTexturePhoto.needsUpdate = true;
        }

        if (htmlVideoScreenObject != null) {
          if (isSignalNotFound) {
            htmlVideo.play();
            htmlVideoScreenObject.visible = true;
          } else {
            htmlVideo.pause();
            htmlVideoScreenObject.visible = false;
          }
        }

        composer.render();
        //stats.update();
      }

      init();
      render();

      //helpers
      function showScene() {
        document.getElementById("loader").style.visibility = "collapse";
        document.getElementById("container").classList.toggle("fadeIn");
      }
    </script>
    <script src="js/color-thief.umd.js"></script>
    <script type="text/javascript">
      const colorThief = new ColorThief();
      let ctxArtist = canvasArtist.getContext("2d");
      let ctxPhoto = canvasPhoto.getContext("2d");

      let albumImg = new Image();
      let photoImg = new Image();

      function livelyPropertyListener(name, val) {
        switch (name) {
          case "imgSelect":
            {
              photoImg.src = val;
            }
            break;
          case "xAngleCamera":
            if (cameraContainer != null) {
              cameraContainer.rotation.x = (Math.PI / 180) * val;
            }
            break;
          case "yAngleCamera":
            if (cameraContainer != null) {
              cameraContainer.rotation.y = (Math.PI / 180) * val;
            }
            break;
          case "30fps":
            fps = val ? 24 : 60;
            break;
        }
      }

      window.onload = () => {
        if (isDebugging) {
          photoImg.src = "photos//jellyfish.jpg";
        }
      };

      photoImg.onload = () => {
        let scaleX = 1,
          scaleY = 1;
        let canvasAspect = canvasPhoto.width / canvasPhoto.height;
        let imgAspect = photoImg.width / photoImg.height;
        if (imgAspect > canvasAspect) scaleX = canvasAspect / imgAspect;
        else scaleY = imgAspect / canvasAspect;

        //console.log(imgAspect + " " +  canvasAspect + " " +scaleX + "/" + scaleY);
        ctxPhoto.clearRect(0, 0, canvasPhoto.width, canvasPhoto.height);
        ctxPhoto.filter = "brightness(90%)";
        drawImage(ctxPhoto, photoImg, canvasPhoto.width / 2, canvasPhoto.height / 2, scaleX, scaleY, -90);
      };

      //ref: https://stackoverflow.com/questions/17411991/html5-canvas-rotate-image
      // x,y position of image center
      function drawImage(ctx, image, x, y, scaleX, scaleY, degree) {
        ctx.setTransform(scaleX, 0, 0, scaleY, x, y);
        ctx.rotate((degree * Math.PI) / 180);
        ctx.drawImage(image, -image.width / 2, -image.height / 2);
      }

      let songTitle = "",
        songArtist = "",
        albumColor = [225, 225, 225];

      function livelyCurrentTrack(data) {
        let obj = JSON.parse(data);
        if (obj == null) {
          isSignalNotFound = true;
          document.body.style.setProperty("--gradientColor1", "#2d2d2d");
        } else {
          songTitle = obj.Title;
          songArtist = obj.Artist;

          isSignalNotFound = false;
          if (obj.Thumbnail == null) {
            ctxArtist.clearRect(0, 0, canvasArtist.width, canvasArtist.height);
            document.body.style.setProperty("--gradientColor1", "#2d2d2d");
            ctxArtist.textAlign = "center";
            ctxArtist.font = songTitle.length > 20 ? "16px Arial, sans-serif" : "25px Arial, sans-serif";
            ctxArtist.fillStyle = `rgb(225,225,225)`;
            ctxArtist.fillText(songTitle, canvasArtist.width / 2, 125 + canvasArtist.height / 2);
            albumColor = [225, 225, 225];
          } else {
            albumImg.src = "data:image/png;base64, " + obj.Thumbnail;
          }
        }
      }

      var lastBass = 1;
      function livelyAudioListener(audioArray) {
        let bass = 0,
          audioIntensity = 1;
        for (let i = 0; i <= 40; i++) bass += audioArray[i] * 2;
        bass /= 40 * 2 * 0.1;
        audioIntensity -= 0.1;
        audioIntensity = (Math.floor(bass * 0.5 * 5) * 10) / 100;
        if (audioIntensity > 1) audioIntensity = 1;
        if (audioIntensity < 0) audioIntensity = 0;

        musicLight.intensity = musicLightIntensity * audioIntensity;
        //lightsMaterial.emissiveIntensity = headLightEmissiveIntensity * audioIntensity;
        //headLight1.intensity = headLight2.intensity = headLightBeamIntensity * audioIntensity;
      }

      albumImg.onload = () => {
        ctxArtist.clearRect(0, 0, canvasArtist.width, canvasArtist.height);

        albumColor = colorThief.getColor(albumImg);
        ctxArtist.drawImage(albumImg, 0, 0, canvasArtist.width, canvasArtist.height);
        /* ctxArtist.textAlign = "center";
        ctxArtist.font = songTitle.length > 20 ? "16px Arial, sans-serif" : "25px Arial, sans-serif";
        ctxArtist.fillStyle = `rgb(${albumColor.toString()}`;
        ctxArtist.fillText(songTitle, canvasArtist.width / 2, 125 + canvasArtist.height / 2); */
        document.body.style.setProperty("--gradientColor1", `rgb(${albumColor.toString()}`);
        //audioLight = rgbToHex(albumColor[0], albumColor[1], albumColor[2]);
        musicLight.color.setRGB(albumColor[0] / 255, albumColor[1] / 255, albumColor[2] / 255);
        console.log(albumColor);
      };

      //https://techfunda.com/howto/1077/digital-clock-animation
      let ctxClock = canvasClock.getContext("2d");
      function updateClock() {
        let date = new Date();
        let str = getTime(date.getHours(), date.getMinutes(), date.getSeconds());

        ctxClock.clearRect(0, 0, canvasClock.width, canvasClock.height);
        ctxClock.font = "110px Arial, sans-serif";
        ctxClock.fillStyle = "white";
        ctxClock.fillText(str, 10, canvasClock.height / 1.5);
      }

      function getTime(hour, min, sec) {
        var curTime;
        if (hour < 10) curTime = "0" + hour.toString();
        else curTime = hour.toString();

        if (min < 10) curTime += ":0" + min.toString();
        else curTime += ":" + min.toString();

        /* if (sec < 10) curTime += ":0" + sec.toString();
        else curTime += ":" + sec.toString(); */
        return curTime;
      }
      setInterval(updateClock, 1000);
    </script>
  </body>
</html>
